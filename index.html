<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flanker Task (Touch Enabled)</title> <style>
        /* Basic CSS */
        body {
            font-family: Arial, sans-serif; text-align: center; background-color: #f8f9fa;
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
            /* Prevent annoying bounce/refresh on mobile */
            overscroll-behavior-y: contain;
        }
        .container {
            max-width: 700px; padding: 30px; border: 1px solid #ccc; background-color: #ffffff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #task { position: relative; }

        #stimulus, #fixation {
            font-size: 80px; font-family: 'Courier New', Courier, monospace; margin: 40px 0;
            height: 90px; line-height: 90px; color: #333;
            white-space: pre;
        }
        #fixation { font-size: 50px; }

        #noiseOverlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-image: radial-gradient(circle, rgba(0,0,0,0.12) 1px, transparent 1px);
            background-size: 3px 3px; opacity: 0.7; pointer-events: none; z-index: 10;
        }

        /* Standard Button Styles (Unaltered) */
        button { padding: 12px 24px; font-size: 18px; margin-top: 25px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; transition: background-color 0.2s ease; }
        button:hover { background-color: #0056b3; }

        .hidden { display: none; }
        #summary ul, #instructions ul, #participantInfo form { display: inline-block; text-align: left; margin-top: 15px; margin-bottom: 15px; }
        #summary li, #instructions li { margin-bottom: 8px; font-size: 16px; } /* Adjusted list item style */
        #participantInfo label, #participantInfo input, #participantInfo select { margin-bottom: 10px; display: block; font-size: 16px; }
        #participantInfo input, #participantInfo select { padding: 8px; margin-left: 5px; min-width: 150px; box-sizing: border-box; width: calc(100% - 10px); } /* Improved form layout */
        #participantInfo label { font-weight: bold; margin-top: 10px; }
        #feedback { font-size: 24px; font-weight: bold; margin-top: 15px; height: 30px; }
        .correct { color: green; }
        .incorrect { color: red; }
        .error-message { color: red; font-size: 14px; margin-top: 10px; }
        #developerDataButton { background-color: #28a745; margin-left: 15px; }
        #developerDataButton:hover { background-color: #218838; }

        /* <<< Step 3: CSS for Touch Buttons >>> */
        #touchResponses {
            margin-top: 25px; display: flex; justify-content: space-around;
            align-items: center; width: 100%;
        }
        .responseBtn {
            padding: 20px 10px; font-size: 18px; font-weight: bold;
            width: 45%; min-height: 80px; cursor: pointer;
            user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
            line-height: 1.3; background-color: #6c757d; color: white;
            border: none; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .responseBtn:hover, .responseBtn:active { background-color: #5a6268; }
        /* Basic responsiveness */
         @media (max-width: 720px) { /* Adjusted breakpoint */
            .container { max-width: 95vw; padding: 15px;}
            #stimulus { font-size: calc(10vw + 20px); height: auto; line-height: 1.2; margin: 20px 0;} /* Responsive font */
            #fixation { font-size: calc(8vw + 15px); height: auto; line-height: 1.2; margin: 20px 0;}
            button { font-size: 16px; padding: 10px 15px; }
            .responseBtn { font-size: 16px; width: 48%; min-height: 70px;}
            #touchResponses { margin-top: 20px; }
         }
         @media (max-width: 480px) { /* Added smaller breakpoint */
             #stimulus { font-size: calc(12vw + 15px); margin: 15px 0;}
             #fixation { font-size: calc(10vw + 10px); margin: 15px 0;}
             .responseBtn { font-size: 14px; width: 47%; min-height: 65px; padding: 15px 5px;}
             #participantInfo input, #participantInfo select { padding: 10px; } /* Easier tap on form */
         }
    </style>
</head>
<body>
    <div class="container">
        <div id="instructions">
            <h2>Welcome to the Flanker Task</h2>
            {/* Unchanged Intro Text */}
            <p>Keep your eyes focused on the center of the screen.</p>
            <p>A '+' cross will appear, then 5 letters.</p>
            <p>Identify the <strong>center letter</strong>.</p>
            {/* <<< Step 5: Updated Instructions >>> */}
            <ul id="instructionList">
                 <li>If center is <strong>A</strong> or <strong>K</strong>: Press <strong>F</strong> or Tap <strong>Left Button</strong></li>
                 <li>If center is <strong>L</strong> or <strong>R</strong>: Press <strong>J</strong> or Tap <strong>Right Button</strong></li>
            </ul>
            <p>Ignore surrounding letters, spacing, and any visual noise.</p>
            <p>Respond quickly and accurately (1.5s limit).</p>
            <p>Click "Continue" to enter your information.</p>
            <button id="continueToInfoBtn">Continue</button>
        </div>

        <div id="participantInfo" class="hidden">
              <h2>Participant Information</h2>
              <form id="infoForm">
                  <label for="participantId">Participant ID (5 digits):</label><input type="text" id="participantId" name="participantId" pattern="\d{5}" required maxlength="5" title="Enter exactly 5 digits">
                  <label for="age">Age:</label><input type="number" id="age" name="age" required min="1" max="120">
                  <label for="gender">Gender:</label><select id="gender" name="gender" required><option value="">--Please select--</option><option value="Male">Male</option><option value="Female">Female</option><option value="Non-binary">Non-binary</option><option value="Other">Other</option><option value="Prefer_not_to_say">Prefer not to say</option></select>
                  <button type="submit" id="startTaskBtn">Start Task</button>
                  <div id="infoError" class="error-message hidden">Please fill out all fields correctly.</div>
              </form>
         </div>

        <div id="task" class="hidden">
            <div id="noiseOverlay" class="hidden"></div>
            <div id="fixation">+</div>
            <div id="stimulus" class="hidden"></div>
            <div id="feedback" class="hidden"></div>
             {/* <<< Step 2: Added Touch Response Buttons >>> */}
             <div id="touchResponses" class="hidden">
                 <button id="touchBtnF" class="responseBtn">A / K<br>(Tap Left)</button>
                 <button id="touchBtnJ" class="responseBtn">L / R<br>(Tap Right)</button>
             </div>
        </div>

        <div id="summary" class="hidden">
              <h2>Task Complete!</h2>
              <p>Here is a summary of your results:</p>
              <div id="summaryResults"></div>
              <button id="restartBtn">Restart Task</button>
              <button id="developerDataButton">Download Raw Data (CSV)</button>
        </div>
    </div>

    <script>
        // --- References (Added touch elements) ---
        const continueToInfoBtn = document.getElementById('continueToInfoBtn');
        const instructionsDiv = document.getElementById('instructions');
        const participantInfoDiv = document.getElementById('participantInfo');
        const infoForm = document.getElementById('infoForm');
        const participantIdInput = document.getElementById('participantId');
        const ageInput = document.getElementById('age');
        const genderInput = document.getElementById('gender');
        const startTaskBtn = document.getElementById('startTaskBtn');
        const infoErrorDiv = document.getElementById('infoError');
        const taskDiv = document.getElementById('task');
        const fixationDiv = document.getElementById('fixation');
        const stimulusDiv = document.getElementById('stimulus');
        const feedbackDiv = document.getElementById('feedback');
        const noiseOverlay = document.getElementById('noiseOverlay');
        const summaryDiv = document.getElementById('summary');
        const summaryResultsDiv = document.getElementById('summaryResults');
        const restartBtn = document.getElementById('restartBtn');
        const developerDataButton = document.getElementById('developerDataButton');
        // <<< Added touch element references >>>
        const touchResponseDiv = document.getElementById('touchResponses');
        const touchBtnF = document.getElementById('touchBtnF');
        const touchBtnJ = document.getElementById('touchBtnJ');

        // --- State (Added listener variables) ---
        let trials = [];
        let currentTrialIndex = 0;
        let results = [];
        let summaryMetrics = {};
        let participantData = {};
        let stimulusStartTime;
        let experimentStartTime;
        let keydownListener = null; // Renamed for clarity
        let touchFListener = null;  // Listener for left button tap
        let touchJListener = null;  // Listener for right button tap
        let trialTimeoutId = null;

        // --- Config (Unaltered) ---
        const FIXATION_DURATION = 500;
        const FEEDBACK_DURATION = 750;
        const ITI = 500;
        const MAX_RESPONSE_TIME = 1500;

        // --- Utilities (Unaltered) ---
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        function calculateSD(data, mean) { if (!data || data.length < 2) return 0; const N = data.length; const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / (N - 1); return Math.sqrt(variance); }
        function calculateMedian(data) { if (!data || data.length === 0) return 0; const sortedData = [...data].sort((a, b) => a - b); const mid = Math.floor(sortedData.length / 2); return sortedData.length % 2 === 0 ? (sortedData[mid - 1] + sortedData[mid]) / 2 : sortedData[mid]; }
        function formatStimulusWithSpacing(stimulusString, spacingType) { const letters = stimulusString.split(''); let space = ''; switch (spacingType) { case 'double': space = '\u00A0'; break; case 'triple': space = '\u00A0\u00A0'; break; default: space = ''; break; } return letters.join(space); }

        // --- Trial Setup (Unaltered) ---
        function setupTrials() { /* ... */ }

        // --- Experiment Flow (Unaltered) ---
        function startExperiment() { /* ... */ }

        // --- <<< NEW: Remove ALL active listeners for a trial >>> ---
        function removeTrialListeners() {
             if (keydownListener) {
                 document.removeEventListener('keydown', keydownListener);
                 keydownListener = null;
                 // console.log("Keydown listener removed."); // Debug log
             }
             if (touchFListener) {
                 touchBtnF.removeEventListener('touchstart', touchFListener);
                 touchFListener = null;
                 // console.log("Touch F listener removed."); // Debug log
             }
             if (touchJListener) {
                 touchBtnJ.removeEventListener('touchstart', touchJListener);
                 touchJListener = null;
                 // console.log("Touch J listener removed."); // Debug log
             }
             // Also clear timeout if listeners are removed due to response/error
             if (trialTimeoutId) {
                 clearTimeout(trialTimeoutId);
                 trialTimeoutId = null;
                 // console.log("Timeout cleared by listener removal."); // Debug log
             }
        }

        // --- Run a Single Trial (Modified to add touch listeners) ---
        function runTrial(trialIndex) {
            if (trialIndex >= trials.length) { endExperiment(); return; }
            const currentTrial = trials[trialIndex];

            removeTrialListeners(); // Clean up listeners from previous trial first

            taskDiv.classList.remove('hidden');
            stimulusDiv.classList.add('hidden');
            feedbackDiv.classList.add('hidden');
            noiseOverlay.classList.add('hidden');
            touchResponseDiv.classList.add('hidden'); // Hide touch buttons initially
            fixationDiv.textContent = '+';
            fixationDiv.classList.remove('hidden');

            setTimeout(() => {
                try {
                    fixationDiv.classList.add('hidden');
                    const formattedStimulus = formatStimulusWithSpacing(currentTrial.stimulus_base, currentTrial.condition_spacing);
                    stimulusDiv.innerHTML = formattedStimulus;
                    stimulusDiv.classList.remove('hidden');
                    if (currentTrial.condition_noise === 'yes') { noiseOverlay.classList.remove('hidden'); }
                    stimulusStartTime = performance.now();

                    // --- Add Listeners ---
                    // Keyboard listener
                    keydownListener = (event) => handleKeyPress(event, currentTrial);
                    document.addEventListener('keydown', keydownListener);
                    // console.log("Keydown listener added for trial", trialIndex); // Debug log

                    // Touch listeners
                    touchResponseDiv.classList.remove('hidden'); // Show buttons now
                    touchFListener = (event) => { event.preventDefault(); handleResponse('f', currentTrial); };
                    touchJListener = (event) => { event.preventDefault(); handleResponse('j', currentTrial); };
                    touchBtnF.addEventListener('touchstart', touchFListener, { passive: false });
                    touchBtnJ.addEventListener('touchstart', touchJListener, { passive: false });
                    // console.log("Touch listeners added for trial", trialIndex); // Debug log

                    // Start the response timeout
                    console.log(`Starting timeout for trial ${trialIndex}`);
                    trialTimeoutId = setTimeout(() => { handleTimeout(currentTrial); }, MAX_RESPONSE_TIME);

                } catch (error) { console.error(`Error setting up trial ${trialIndex}:`, error); }
            }, FIXATION_DURATION);
        }

        // --- Handle Key Press (Simplified to call handleResponse) ---
        function handleKeyPress(event, trial) {
            const key = event.key.toLowerCase();
            if (key === 'f' || key === 'j') {
                 // Check if a listener still exists (to prevent double processing if timeout is racing)
                 if (!keydownListener && !touchFListener && !touchJListener) {
                      console.warn("handleKeyPress called but listeners already removed for trial", currentTrialIndex);
                      return;
                 }
                handleResponse(key, trial);
            }
        }

        // --- >>> NEW: Central Response Handler <<< ---
        function handleResponse(responseKey, trial) {
             console.log(`Handling response: ${responseKey} for trial ${currentTrialIndex}`);

             // If timeout already cleared (by another event), do nothing more here
             if (trialTimeoutId === null && !results.some(r => r.trialIndex === currentTrialIndex)) {
                 console.warn(`handleResponse (${responseKey}) called for trial ${currentTrialIndex}, but timeoutId is already null. Likely double trigger/race condition.`);
                 // If timeout is null AND result exists, timeout already handled it.
                 // If timeout is null AND result doesn't exist, something is odd, but let's prevent double processing.
                 removeTrialListeners(); // Clean up any remaining listeners just in case
                 return;
             }

             // Prevent processing if result already logged (e.g. race condition btn timeout & keypress)
              if(results.some(r => r.trialIndex === currentTrialIndex)) {
                 console.log(`Result for trial ${currentTrialIndex} already recorded, ignoring response ${responseKey}.`);
                 removeTrialListeners(); // Still cleanup listeners
                 return;
              }

             // 1. Clear Timeout & Remove ALL Listeners immediately
             removeTrialListeners();

             // 2. Calculate RT and Correctness
             const reactionTime = performance.now() - stimulusStartTime;
             let expectedKey; const centerLower = trial.centerLetter.toLowerCase();
             if (['a', 'k'].includes(centerLower)) expectedKey = 'f'; else if (['l', 'r'].includes(centerLower)) expectedKey = 'j'; else expectedKey = '?';
             const correct = responseKey === expectedKey;

             // 3. Hide Stimulus Elements
             stimulusDiv.classList.add('hidden');
             noiseOverlay.classList.add('hidden');
             touchResponseDiv.classList.add('hidden');

             // 4. Record Result (make sure this is the only place results are pushed for a given trial index)
             results.push({
                 participantId: participantData.id, age: participantData.age, gender: participantData.gender,
                 trialIndex: currentTrialIndex, stimulus: trial.stimulus_base, centerLetter: trial.centerLetter,
                 congruency: trial.condition_congruency, noise: trial.condition_noise, spacing: trial.condition_spacing,
                 response: responseKey, correctKey: expectedKey, correct: correct ? 1 : 0,
                 latency_ms: reactionTime
             });

             // 5. Show Feedback
             showFeedback(correct ? "Correct" : "Incorrect");

             // 6. Schedule Next Trial
             setTimeout(() => {
                 currentTrialIndex++;
                 runTrial(currentTrialIndex);
             }, FEEDBACK_DURATION + ITI);
        }


        // --- Handle Timeout (Modified to use removeTrialListeners) ---
        function handleTimeout(trial) {
             console.warn(`Timeout occurred for trial ${currentTrialIndex}`);
             trialTimeoutId = null; // Mark timeout as having occurred/handled

             // Avoid double processing if response happened almost simultaneously
             if(results.some(r => r.trialIndex === currentTrialIndex)) {
                 console.log(`Result for trial ${currentTrialIndex} already recorded, ignoring timeout.`);
                 removeTrialListeners(); // Cleanup listeners anyway
                 return;
              }

             // Remove any remaining listeners
             removeTrialListeners();

             stimulusDiv.classList.add('hidden');
             noiseOverlay.classList.add('hidden');
             touchResponseDiv.classList.add('hidden');

             // Record timeout result
             results.push({
                 participantId: participantData.id, age: participantData.age, gender: participantData.gender,
                 trialIndex: currentTrialIndex, stimulus: trial.stimulus_base, centerLetter: trial.centerLetter,
                 congruency: trial.condition_congruency, noise: trial.condition_noise, spacing: trial.condition_spacing,
                 response: 'timeout', correctKey: trial.correctKey, correct: 0,
                 latency_ms: -1 // Use -1 for timeout latency
             });

             showFeedback("Too Slow");

             setTimeout(() => {
                  currentTrialIndex++;
                  runTrial(currentTrialIndex);
             }, FEEDBACK_DURATION + ITI);
        }

        // --- Show Feedback (Unaltered) ---
        function showFeedback(message) { feedbackDiv.classList.remove('hidden'); if (message === "Correct") { feedbackDiv.className = 'correct'; feedbackDiv.textContent = "Correct"; } else { feedbackDiv.className = 'incorrect'; feedbackDiv.textContent = message; } }

        // --- End Experiment (Added cleanup) ---
        function endExperiment() {
              // Ensure final trial listeners/timeout are cleared
              removeTrialListeners();

              const experimentEndTime = performance.now(); const totalElapsedTime_ms = experimentEndTime - experimentStartTime; console.log("Experiment ended. Calculating metrics...");
              taskDiv.classList.add('hidden'); touchResponseDiv.classList.add('hidden'); // Hide buttons

              // Calculation logic remains the same...
              let correctCount = 0; let totalCorrectRT = 0; let correctRTs = []; let noiseYesCorrect = 0, noiseYesTotal = 0; let noiseNoCorrect = 0, noiseNoTotal = 0; let spacingSingleCorrect = 0, spacingSingleTotal = 0; let spacingDoubleCorrect = 0, spacingDoubleTotal = 0; let spacingTripleCorrect = 0, spacingTripleTotal = 0; let timeoutCount = 0;
              results.forEach(res => { if (res.noise === 'yes') noiseYesTotal++; else noiseNoTotal++; if (res.spacing === 'single') spacingSingleTotal++; else if (res.spacing === 'double') spacingDoubleTotal++; else if (res.spacing === 'triple') spacingTripleTotal++; if (res.response === 'timeout') { timeoutCount++; } else if (res.correct === 1) { correctCount++; if (res.latency_ms !== -1) { totalCorrectRT += res.latency_ms; correctRTs.push(res.latency_ms); } if (res.noise === 'yes') noiseYesCorrect++; else noiseNoCorrect++; if (res.spacing === 'single') spacingSingleCorrect++; else if (res.spacing === 'double') spacingDoubleCorrect++; else if (res.spacing === 'triple') spacingTripleCorrect++; } });
              const totalTrials = results.length; const respondedTrials = totalTrials - timeoutCount; const overallAccuracy = totalTrials > 0 ? (correctCount / totalTrials) * 100 : 0; const accuracyResponded = respondedTrials > 0 ? (correctCount / respondedTrials) * 100 : 0; const overallErrorRate = 100 - overallAccuracy;
              const overallMeanRT = correctCount > 0 ? (totalCorrectRT / correctCount) : 0; const overallSDRT = calculateSD(correctRTs, overallMeanRT); const overallMinRT = correctRTs.length > 0 ? Math.min(...correctRTs) : 0; const overallMaxRT = correctRTs.length > 0 ? Math.max(...correctRTs) : 0; const overallMedianRT = calculateMedian(correctRTs);
              const accuracyNoiseYes = noiseYesTotal > 0 ? (results.filter(r => r.noise === 'yes' && r.correct === 1).length / noiseYesTotal) * 100 : 0; const accuracyNoiseNo = noiseNoTotal > 0 ? (results.filter(r => r.noise === 'no' && r.correct === 1).length / noiseNoTotal) * 100 : 0; const accuracySpacingSingle = spacingSingleTotal > 0 ? (results.filter(r => r.spacing === 'single' && r.correct === 1).length / spacingSingleTotal) * 100 : 0; const accuracySpacingDouble = spacingDoubleTotal > 0 ? (results.filter(r => r.spacing === 'double' && r.correct === 1).length / spacingDoubleTotal) * 100 : 0; const accuracySpacingTriple = spacingTripleTotal > 0 ? (results.filter(r => r.spacing === 'triple' && r.correct === 1).length / spacingTripleTotal) * 100 : 0;
             summaryMetrics = { totalElapsedTime_s: (totalElapsedTime_ms / 1000).toFixed(2), totalTrials: totalTrials, timeoutCount: timeoutCount, overallAccuracy: overallAccuracy.toFixed(2), overallErrorRate: overallErrorRate.toFixed(2), accuracyAmongResponded: accuracyResponded.toFixed(2), overallMeanRT_ms: overallMeanRT.toFixed(2), overallMedianRT_ms: overallMedianRT.toFixed(2), overallMinRT_ms: overallMinRT.toFixed(2), overallMaxRT_ms: overallMaxRT.toFixed(2), overallSDRT_ms: overallSDRT.toFixed(2), accuracyNoiseYes: accuracyNoiseYes.toFixed(2), accuracyNoiseNo: accuracyNoiseNo.toFixed(2), accuracySpacingSingle: accuracySpacingSingle.toFixed(2), accuracySpacingDouble: accuracySpacingDouble.toFixed(2), accuracySpacingTriple: accuracySpacingTriple.toFixed(2), };
             console.log("Summary Metrics:", summaryMetrics);
             // Display logic remains the same...
             summaryResultsDiv.innerHTML = ` <ul> <li>Total Task Time: ${summaryMetrics.totalElapsedTime_s} seconds</li> <li>Overall Accuracy (incl. Timeouts): ${summaryMetrics.overallAccuracy}% (${correctCount}/${totalTrials})</li> <li>Timeouts: ${summaryMetrics.timeoutCount}</li> <li>Accuracy (Responded Trials Only): ${summaryMetrics.accuracyAmongResponded}%</li> <li>Mean Correct Latency (Responded Trials): ${summaryMetrics.overallMeanRT_ms} ms</li> <li>Median Correct Latency (Responded Trials): ${summaryMetrics.overallMedianRT_ms} ms</li> <li>Latency Range (Min-Max, Correct & Responded): ${summaryMetrics.overallMinRT_ms} - ${summaryMetrics.overallMaxRT_ms} ms</li> <li>Accuracy by Noise (No / Yes): ${summaryMetrics.accuracyNoiseNo}% / ${summaryMetrics.accuracyNoiseYes}%</li> <li>Accuracy by Spacing (Single / Double / Triple): ${summaryMetrics.accuracySpacingSingle}% / ${summaryMetrics.accuracySpacingDouble}% / ${summaryMetrics.accuracySpacingTriple}%</li> </ul>`;
             summaryDiv.classList.remove('hidden');

             // --- Prepare Data for Google Sheet (Unaltered) ---
             console.log("Preparing full data for Google Sheet...");
             const dataForSheet = { participantID: participantData.id, age: participantData.age, gender: participantData.gender, rawData: results, summaryData: summaryMetrics };
             console.log("Data prepared for Google Sheet:", JSON.stringify(dataForSheet).substring(0, 500) + "...");
             sendDataToSheetGoogle(dataForSheet); // <<< UNALTERED CALL
         }

        // --- Data Conversion/Download (Unaltered) ---
        function convertToCSV(dataArray) { /* ... */ }
        function downloadCSVData() { /* ... */ }

        // --- Event Listeners (Unaltered) ---
        continueToInfoBtn.addEventListener('click', () => { /* ... */ });
        infoForm.addEventListener('submit', (event) => { /* ... */ });
        restartBtn.addEventListener('click', () => { /* ... */ });
        developerDataButton.addEventListener('click', downloadCSVData);

        // --- Utility Functions Implementation (Ensure full definitions are present) ---
        // (Definitions for shuffleArray, calculateSD, calculateMedian, formatStimulusWithSpacing included earlier)

    </script>
    <script>
      function sendDataToSheetGoogle(dataPayload) {
        console.log("Attempting to send data via fetch (no-cors):", JSON.stringify(dataPayload).substring(0, 500) + "...");
        fetch("https://script.google.com/macros/s/AKfycbymjapc5sya9P9xXTjDnD5vO7o7ooA0-ORXuMP6to9CcaL_O3MEH87EiALNOlEv_jO5Sw/exec", { // Use your exact deployment URL
          method: "POST",
          headers: { "Content-Type": "application/json", },
          body: JSON.stringify(dataPayload),
          mode: 'no-cors' // Keep no-cors as it's working
        })
        .then(() => { console.log("Data submission fetch initiated (mode: no-cors). Check Google Sheet/Logs."); })
        .catch((error) => { console.error("❌ Error initiating fetch:", error); alert("Network error sending data."); });
      }
    </script>
    </body>
</html>
