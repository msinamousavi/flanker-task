<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flanker Task (Revised)</title>
    <style>
        /* Basic CSS */
        body {
            font-family: Arial, sans-serif; text-align: center; background-color: #f8f9fa;
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
        }
        .container {
            max-width: 700px; padding: 30px; border: 1px solid #ccc; background-color: #ffffff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        /* Task Area Positioning */
        #task { position: relative; } /* Needed for noise overlay positioning */

        #stimulus, #fixation {
            font-size: 80px; font-family: 'Courier New', Courier, monospace; margin: 40px 0;
            height: 90px; line-height: 90px; color: #333;
        }
        #fixation { font-size: 50px; }

        /* Noise Overlay Styling */
        #noiseOverlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            /* Example subtle noise pattern */
            background-image: radial-gradient(circle, rgba(0,0,0,0.08) 1px, transparent 1px);
            background-size: 4px 4px; /* Adjust pattern density */
            opacity: 0.6; /* Adjust visibility */
            pointer-events: none; /* Ignore mouse events */
            z-index: 10; /* Position above stimulus if needed */
        }

        button { /* Styles from previous version... */ }
        button:hover { background-color: #0056b3; }
        .hidden { display: none; }
        #summary ul, #instructions ul, #participantInfo form { /* Styles from previous version... */ }
        #summary li, #instructions li, #participantInfo label, #participantInfo input, #participantInfo select { /* Styles from previous version... */ }
        #participantInfo input, #participantInfo select { /* Styles from previous version... */ }
        #participantInfo label { /* Styles from previous version... */ }
        #feedback { /* Styles from previous version... */ }
        .correct { color: green; }
        .incorrect { color: red; }
        .error-message { /* Styles from previous version... */ }
        #developerDataButton { /* Styles from previous version... */ }
        #developerDataButton:hover { /* Styles from previous version... */ }
    </style>
</head>
<body>
    <div class="container">
        <div id="instructions">
            <h2>Welcome to the Flanker Task</h2>
            <p>Please read the instructions carefully.</p>
            <p>You will first be asked for some basic information.</p>
            <p>Keep your eyes focused on the center of the screen.</p>
            <p>A fixation cross '+' will appear, followed by a sequence of 5 letters.</p>
            <p>Some trials may have visual noise overlaying the letters.</p>
            <p>Your task is to identify the <strong>center letter</strong> and ignore the surrounding letters.</p>
            <ul id="instructionList">
                 <li>Press <strong>F</strong> if the center letter is <strong>A</strong> or <strong>K</strong></li>
                 <li>Press <strong>J</strong> if the center letter is <strong>L</strong> or <strong>R</strong></li>
            </ul>
            <p>Please respond as quickly and accurately as possible.</p>
            <p>Click "Continue" to enter your information.</p>
            <button id="continueToInfoBtn">Continue</button>
        </div>

        <div id="participantInfo" class="hidden">
            <h2>Participant Information</h2>
            <form id="infoForm">
                 <label for="participantId">Participant ID (5 digits):</label>
                 <input type="text" id="participantId" name="participantId" pattern="\d{5}" required maxlength="5" title="Enter exactly 5 digits">
                 <label for="age">Age:</label>
                 <input type="number" id="age" name="age" required min="1" max="120">
                 <label for="gender">Gender:</label>
                 <select id="gender" name="gender" required>
                     <option value="">--Please select--</option>
                     <option value="Male">Male</option>
                     <option value="Female">Female</option>
                     <option value="Non-binary">Non-binary</option>
                     <option value="Other">Other</option>
                     <option value="Prefer_not_to_say">Prefer not to say</option>
                 </select>
                 <button type="submit" id="startTaskBtn">Start Task</button>
                 <div id="infoError" class="error-message hidden">Please fill out all fields correctly.</div>
            </form>
        </div>

        <div id="task" class="hidden">
            <div id="noiseOverlay" class="hidden"></div> <div id="fixation">+</div>
            <div id="stimulus" class="hidden"></div>
            <div id="feedback" class="hidden"></div>
        </div>

        <div id="summary" class="hidden">
             <h2>Task Complete!</h2>
             <p>Here is a summary of your results:</p>
             <div id="summaryResults">
                 </div>
             <button id="restartBtn">Restart Task</button>
             <button id="developerDataButton">Download Raw Data (JSON)</button>
        </div>
    </div>

    <script>
        // --- Get References (Add noiseOverlay) ---
        const continueToInfoBtn = document.getElementById('continueToInfoBtn');
        const instructionsDiv = document.getElementById('instructions');
        // ... (references from provided code) ...
        const participantInfoDiv = document.getElementById('participantInfo');
        const infoForm = document.getElementById('infoForm');
        const participantIdInput = document.getElementById('participantId');
        const ageInput = document.getElementById('age');
        const genderInput = document.getElementById('gender');
        const startTaskBtn = document.getElementById('startTaskBtn');
        const infoErrorDiv = document.getElementById('infoError');
        const taskDiv = document.getElementById('task');
        const fixationDiv = document.getElementById('fixation');
        const stimulusDiv = document.getElementById('stimulus');
        const feedbackDiv = document.getElementById('feedback');
        const noiseOverlay = document.getElementById('noiseOverlay'); // Added noise overlay ref
        const summaryDiv = document.getElementById('summary');
        const summaryResultsDiv = document.getElementById('summaryResults');
        const restartBtn = document.getElementById('restartBtn');
        const developerDataButton = document.getElementById('developerDataButton');


        // --- Task State Variables ---
        let trials = [];
        let currentTrialIndex = 0;
        let results = [];
        let summaryMetrics = {};
        let participantData = {};
        let stimulusStartTime;
        let responseListener = null;

        // --- Timing Parameters ---
        const FIXATION_DURATION = 500;
        const FEEDBACK_DURATION = 750;
        const ITI = 500;

        // --- Utility Functions ---
        function shuffleArray(array) { /* ... (same as provided) ... */ }
        // Updated SD to use Sample SD (N-1)
        function calculateSD(data, mean) {
            if (!data || data.length < 2) return 0; // Need at least 2 points for sample SD
            const N = data.length;
            const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / (N - 1);
            return Math.sqrt(variance);
        }
         // Added Median calculation
         function calculateMedian(data) {
             if (!data || data.length === 0) return 0;
             const sortedData = [...data].sort((a, b) => a - b); // Sort numeric
             const mid = Math.floor(sortedData.length / 2);
             if (sortedData.length % 2 === 0) { // Even length
                 return (sortedData[mid - 1] + sortedData[mid]) / 2;
             } else { // Odd length
                 return sortedData[mid];
             }
         }

        // --- Define Trials (96 trials: 2 Congruency x 2 Noise x 2 Target Sets x 12 Reps) ---
        function setupTrials() {
            const letters = {
                set1: ['A', 'K'], // Respond 'F'
                set2: ['L', 'R']  // Respond 'J'
            };
            const conditions = {
                congruency: ['congruent', 'incongruent'],
                noise: ['no', 'yes']
            };

            const baseTrials = [];
            // Create 1 instance of each unique condition combo
            for (const cong of conditions.congruency) {
                for (const noiseType of conditions.noise) {
                    // Create trials for both target sets (A/K vs L/R)
                    for (const targetSetKey in letters) {
                         const targetSet = letters[targetSetKey];
                         const flankerSet = targetSetKey === 'set1' ? letters.set2 : letters.set1;
                         const correctKey = targetSetKey === 'set1' ? 'f' : 'j';

                         // Pick target letter from the set (can alternate or be random)
                         const targetLetter = targetSet[Math.floor(Math.random() * targetSet.length)];

                         let stimulus = "";
                         if (cong === 'congruent') {
                             // Center is target, flankers match target
                             stimulus = targetLetter.repeat(5);
                         } else { // incongruent
                             // Center is target, flankers are from the *other* response set
                             const flankerLetter = flankerSet[Math.floor(Math.random() * flankerSet.length)];
                             stimulus = `${flankerLetter}${flankerLetter}${targetLetter}${flankerLetter}${flankerLetter}`;
                         }

                         baseTrials.push({
                             stimulus: stimulus,
                             centerLetter: targetLetter, // Store the specific center letter
                             correctKey: correctKey, // Store the correct key ('f' or 'j')
                             condition_congruency: cong,
                             condition_noise: noiseType
                         });
                    } // End target set loop
                } // End noise loop
            } // End congruency loop

            // Repeat the unique conditions to get 96 trials (8 unique types * 12 reps)
             const repeatedTrials = [];
             const reps = 12;
             for (let i=0; i<reps; i++){
                // Add copies of base trials
                repeatedTrials.push(...baseTrials.map(trial => ({...trial})));
             }

            trials = shuffleArray(repeatedTrials);
            currentTrialIndex = 0;
            results = [];
            console.log(`Setup complete: ${trials.length} trials generated.`);
        }


        // --- Start Experiment Flow (Same as provided) ---
        function startExperiment() { /* ... */ }

        // --- Run a Single Trial (Integrate Noise) ---
        function runTrial(trialIndex) {
            if (trialIndex >= trials.length) {
                endExperiment(); return;
            }
            const currentTrial = trials[trialIndex];

            // Reset visual state
            taskDiv.classList.remove('hidden');
            stimulusDiv.classList.add('hidden');
            feedbackDiv.classList.add('hidden');
            noiseOverlay.classList.add('hidden'); // Make sure noise is hidden
            fixationDiv.textContent = '+';
            fixationDiv.classList.remove('hidden');

            // Show fixation, then stimulus after delay
            setTimeout(() => {
                fixationDiv.classList.add('hidden'); // Hide fixation

                // Prepare and show stimulus
                stimulusDiv.textContent = currentTrial.stimulus;
                stimulusDiv.classList.remove('hidden');

                // Show noise if it's a noise trial
                if (currentTrial.condition_noise === 'yes') {
                    noiseOverlay.classList.remove('hidden');
                }

                stimulusStartTime = performance.now(); // Record time

                // Add keyboard listener
                if (responseListener) document.removeEventListener('keydown', responseListener);
                responseListener = (event) => handleKeyPress(event, currentTrial);
                document.addEventListener('keydown', responseListener);

            }, FIXATION_DURATION);
        }

        // --- Handle Key Press (Check A/K vs L/R) ---
        function handleKeyPress(event, trial) {
            const key = event.key.toLowerCase();
            if (key === 'f' || key === 'j') {
                 const reactionTime = performance.now() - stimulusStartTime;

                 // Determine correct key based on the center letter
                 let expectedKey;
                 const centerLower = trial.centerLetter.toLowerCase();
                 if (['a', 'k'].includes(centerLower)) {
                     expectedKey = 'f';
                 } else if (['l', 'r'].includes(centerLower)) {
                     expectedKey = 'j';
                 } else {
                     expectedKey = '?'; // Fallback, should not occur
                     console.error("Error determining expected key for center letter:", trial.centerLetter);
                 }
                 const correct = key === expectedKey;

                 document.removeEventListener('keydown', responseListener);
                 responseListener = null;
                 stimulusDiv.classList.add('hidden');
                 noiseOverlay.classList.add('hidden'); // Hide noise overlay after response

                 // Store results with new fields
                 results.push({
                     participantId: participantData.id,
                     age: participantData.age,
                     gender: participantData.gender,
                     trialIndex: currentTrialIndex,
                     stimulus: trial.stimulus,
                     centerLetter: trial.centerLetter,
                     congruency: trial.condition_congruency, // Keep field names consistent
                     noise: trial.condition_noise,          // Keep field names consistent
                     response: key,
                     correctKey: expectedKey,
                     correct: correct ? 1 : 0,
                     rt: reactionTime
                 });

                 showFeedback(correct);

                 setTimeout(() => {
                     currentTrialIndex++;
                     runTrial(currentTrialIndex);
                 }, FEEDBACK_DURATION + ITI);
            }
        }

        // --- Show Feedback (Same as provided) ---
        function showFeedback(correct) { /* ... */ }

        // --- End Experiment (Add Min/Max/Median RT calculation) ---
        function endExperiment() {
            console.log("Experiment ended. Calculating metrics...");
            taskDiv.classList.add('hidden');

            // --- Calculations ---
            let correctCount = 0;
            let totalCorrectRT = 0;
            let correctRTs = []; // Array for Min/Max/Median/SD calculation

            let congruentCorrectCount = 0;
            let incongruentCorrectCount = 0;
            let congruentTotal = 0;
            let incongruentTotal = 0;
            let congruentCorrectRTtotal = 0;
            let incongruentCorrectRTtotal = 0;
            let congruentCorrectRTs = [];
            let incongruentCorrectRTs = [];
            // Can add counters/arrays for Noise conditions here if needed for breakdown

            results.forEach(res => {
                // Use the 'congruency' field name used in results.push
                if (res.congruency === 'congruent') congruentTotal++;
                if (res.congruency === 'incongruent') incongruentTotal++;

                if (res.correct === 1) {
                    correctCount++;
                    totalCorrectRT += res.rt;
                    correctRTs.push(res.rt); // Collect all correct RTs

                    if (res.congruency === 'congruent') {
                        congruentCorrectCount++;
                        congruentCorrectRTtotal += res.rt;
                        congruentCorrectRTs.push(res.rt);
                    } else if (res.congruency === 'incongruent') {
                        incongruentCorrectCount++;
                        incongruentCorrectRTtotal += res.rt;
                        incongruentCorrectRTs.push(res.rt);
                    }
                     // Can add logic here to collect RTs based on 'noise' field if needed
                }
            });

             const totalTrials = results.length;
             const overallAccuracy = totalTrials > 0 ? (correctCount / totalTrials) * 100 : 0;
             const overallMeanRT = correctCount > 0 ? (totalCorrectRT / correctCount) : 0;
             const overallSDRT = calculateSD(correctRTs, overallMeanRT); // Use sample SD
             const errorRate = 100 - overallAccuracy;

             // Calculate NEW Overall RT Metrics
             const overallMinRT = correctRTs.length > 0 ? Math.min(...correctRTs) : 0;
             const overallMaxRT = correctRTs.length > 0 ? Math.max(...correctRTs) : 0;
             const overallMedianRT = calculateMedian(correctRTs);

             // Congruency calculations (same as provided code, using correct field name 'congruency')
             const congruentAccuracy = congruentTotal > 0 ? (congruentCorrectCount / congruentTotal) * 100 : 0;
             const incongruentAccuracy = incongruentTotal > 0 ? (incongruentCorrectCount / incongruentTotal) * 100 : 0;
             const congruentMeanRT = congruentCorrectCount > 0 ? (congruentCorrectRTtotal / congruentCorrectCount) : 0;
             const incongruentMeanRT = incongruentCorrectCount > 0 ? (incongruentCorrectRTtotal / incongruentCorrectCount) : 0;
             const congruentSDRT = calculateSD(congruentCorrectRTs, congruentMeanRT);
             const incongruentSDRT = calculateSD(incongruentCorrectRTs, incongruentMeanRT);
             const interferenceRT = (congruentMeanRT > 0 && incongruentMeanRT > 0) ? (incongruentMeanRT - congruentMeanRT) : 'N/A';
             const interferenceAccuracy = (congruentAccuracy - incongruentAccuracy);


            // Store calculated metrics (add new ones)
            summaryMetrics = {
                totalTrials: totalTrials,
                overallAccuracy: overallAccuracy.toFixed(2),
                overallMeanRT_ms: overallMeanRT.toFixed(2),
                overallMedianRT_ms: overallMedianRT.toFixed(2), // Added Median
                overallMinRT_ms: overallMinRT.toFixed(2),       // Added Min
                overallMaxRT_ms: overallMaxRT.toFixed(2),       // Added Max
                overallSDRT_ms: overallSDRT.toFixed(2),         // Now Sample SD
                errorRate: errorRate.toFixed(2),
                congruentTotal: congruentTotal,
                congruentAccuracy: congruentAccuracy.toFixed(2),
                congruentMeanRT_ms: congruentMeanRT.toFixed(2),
                congruentSDRT_ms: congruentSDRT.toFixed(2),
                incongruentTotal: incongruentTotal,
                incongruentAccuracy: incongruentAccuracy.toFixed(2),
                incongruentMeanRT_ms: incongruentMeanRT.toFixed(2),
                incongruentSDRT_ms: incongruentSDRT.toFixed(2),
                interferenceRT_ms: typeof interferenceRT === 'number' ? interferenceRT.toFixed(2) : interferenceRT,
                interferenceAccuracy: interferenceAccuracy.toFixed(2)
                // Add metrics for Noise condition breakdown if calculated
            };

            console.log("Summary Metrics:", summaryMetrics);

            // Display summary to participant (add Median, Min, Max)
            summaryResultsDiv.innerHTML = `
                <ul>
                    <li>Overall Accuracy: ${summaryMetrics.overallAccuracy}%</li>
                    <li>Mean Correct Reaction Time: ${summaryMetrics.overallMeanRT_ms} ms</li>
                    <li>Median Correct Reaction Time: ${summaryMetrics.overallMedianRT_ms} ms</li>
                    <li>Correct RT Range (Min-Max): ${summaryMetrics.overallMinRT_ms} - ${summaryMetrics.overallMaxRT_ms} ms</li>
                    <li>RT Standard Deviation: ${summaryMetrics.overallSDRT_ms} ms</li>
                    <li>Flanker RT Interference: ${summaryMetrics.interferenceRT_ms} ms</li>
                </ul>
            `;
            summaryDiv.classList.remove('hidden');
        }

        // --- Function to trigger JSON download (Same as provided) ---
        function downloadData() { /* ... (same as provided) ... */ }


        // --- Event Listeners (Same as provided) ---
        continueToInfoBtn.addEventListener('click', () => { /* ... */ });
        infoForm.addEventListener('submit', (event) => { /* ... */ });
        restartBtn.addEventListener('click', () => { /* ... */ });
        developerDataButton.addEventListener('click', downloadData);

         // --- Utility Functions Implementation (need to be defined) ---
         function shuffleArray(array) {
             for (let i = array.length - 1; i > 0; i--) {
                 const j = Math.floor(Math.random() * (i + 1));
                 [array[i], array[j]] = [array[j], array[i]]; // Swap elements
             }
             return array;
         }
         // Make sure all functions referenced (like startExperiment) are defined
         // (Copying from provided code for completeness)
         function startExperiment() {
             console.log("Starting experiment for participant:", participantData);
             setupTrials();
             if (trials.length > 0) {
                 runTrial(currentTrialIndex);
             } else {
                 console.error("No trials defined!");
             }
         }
         function downloadData() {
             const dataStr = JSON.stringify({
                 participantInfo: participantData,
                 summaryMetrics: summaryMetrics,
                 rawData: results // Ensure 'results' contains the detailed trial data
             }, null, 2);

             const blob = new Blob([dataStr], {type: "application/json"});
             const url = URL.createObjectURL(blob);
             const a = document.createElement('a');
             const date = new Date();
             const timestamp = `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, '0')}${String(date.getDate()).padStart(2, '0')}_${String(date.getHours()).padStart(2, '0')}${String(date.getMinutes()).padStart(2, '0')}${String(date.getSeconds()).padStart(2, '0')}`;
             a.download = `flanker_results_${participantData.id}_${timestamp}.json`;
             a.href = url;
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);
             URL.revokeObjectURL(url);
             console.log("JSON Data download initiated.");
         }
         // Event Listeners (Copied from provided for completeness)
         continueToInfoBtn.addEventListener('click', () => {
             instructionsDiv.classList.add('hidden');
             participantInfoDiv.classList.remove('hidden');
         });
         infoForm.addEventListener('submit', (event) => {
             event.preventDefault();
             const id = participantIdInput.value;
             const age = ageInput.value;
             const gender = genderInput.value;
             if (id.match(/^\d{5}$/) && age && gender) {
                 participantData = { id: id, age: parseInt(age), gender: gender };
                 infoErrorDiv.classList.add('hidden');
                 participantInfoDiv.classList.add('hidden');
                 startExperiment();
             } else {
                 infoErrorDiv.textContent = "Please ensure ID is 5 digits and all fields are filled.";
                 infoErrorDiv.classList.remove('hidden');
             }
         });
         restartBtn.addEventListener('click', () => {
             summaryDiv.classList.add('hidden');
             instructionsDiv.classList.remove('hidden');
         });
         developerDataButton.addEventListener('click', downloadData);

    </script>
</body>
</html>
