<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flanker Task (Enhanced)</title>
    <style>
        /* Basic CSS - Consider adding more specific styles for the form */
        body { /* Styles from previous version... */ }
        .container { /* Styles from previous version... */ }

        /* Stimulus/Fixation Area - Added position relative for overlay */
        #task { position: relative; }
        #stimulus, #fixation { /* Styles from previous version... */ }
        #fixation { /* Styles from previous version... */ }

        /* Noise Overlay Element */
        #noiseOverlay {
            position: absolute; /* Position over the stimulus area */
            top: 0; left: 0; right: 0; bottom: 0;
            /* Example using subtle dots pattern (CSS gradient) */
            background-image: radial-gradient(circle, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 5px 5px; /* Adjust size of pattern */
            opacity: 0.5; /* Adjust transparency */
            pointer-events: none; /* Allow clicks through */
            z-index: 10; /* Ensure it's above fixation/stimulus if needed */
        }

        button { /* Styles from previous version... */ }
        .hidden { display: none; }
        #summary ul, #instructions ul, #participantInfo form { /* Styles from previous version... */ }
        #summary li, #instructions li, #participantInfo label, #participantInfo input, #participantInfo select { /* Styles from previous version... */ }
        #participantInfo input, #participantInfo select { /* Styles from previous version... */ }
        #participantInfo label { /* Styles from previous version... */ }
        #feedback { /* Styles from previous version... */ }
        .correct { color: green; }
        .incorrect { color: red; }
        .error-message { /* Styles from previous version... */ }
        #developerDataContainer { margin-top: 20px; } /* Container for download buttons */
        #developerDataButtonJson, #developerDataButtonCsv { background-color: #6c757d; margin-left: 10px; }
        #developerDataButtonJson:hover, #developerDataButtonCsv:hover { background-color: #5a6268; }

    </style>
</head>
<body>
    <div class="container">
        <div id="instructions">
             <h2>Welcome to the Enhanced Flanker Task</h2>
             <p>Please read the instructions carefully.</p>
             <p>You will first be asked for some basic information.</p>
             <p>Throughout the task, keep your eyes focused on the center of the screen.</p>
             <p>A fixation cross '+' will appear, sometimes followed by a brief cue '*'.</p>
             <p>Then, a sequence of 5 letters will appear. Some trials may have visual noise overlaying the letters.</p>
             <p>Your task is to identify the <strong>center letter</strong> and ignore the surrounding letters.</p>
             <ul>
                 <li>Press <strong>F</strong> if the center letter is <strong>A</strong> or <strong>K</strong></li>
                 <li>Press <strong>J</strong> if the center letter is <strong>L</strong> or <strong>R</strong></li>
             </ul>
             <p>Please respond as quickly and accurately as possible.</p>
             <p>Click "Continue" to enter your information.</p>
             <button id="continueToInfoBtn">Continue</button>
        </div>

        <div id="participantInfo" class="hidden">
            <h2>Participant Information</h2>
            <form id="infoForm">
                <label for="participantId">Participant ID (5 digits):</label>
                <input type="text" id="participantId" name="participantId" pattern="\d{5}" required maxlength="5" title="Enter exactly 5 digits">
                 <label for="age">Age:</label>
                 <input type="number" id="age" name="age" required min="1" max="120">
                 <label for="gender">Gender:</label>
                 <select id="gender" name="gender" required>
                     <option value="">--Please select--</option>
                     <option value="Male">Male</option>
                     <option value="Female">Female</option>
                     <option value="Non-binary">Non-binary</option>
                     <option value="Other">Other</option>
                     <option value="Prefer_not_to_say">Prefer not to say</option>
                 </select>
                 <button type="submit" id="startTaskBtn">Start Task</button>
                 <div id="infoError" class="error-message hidden">Please fill out all fields correctly.</div>
            </form>
        </div>

        <div id="task" class="hidden">
            <div id="noiseOverlay" class="hidden"></div> <div id="fixation">+</div>
            <div id="stimulus" class="hidden"></div>
            <div id="feedback" class="hidden"></div>
        </div>

        <div id="summary" class="hidden">
            <h2>Task Complete!</h2>
            <p>Here is a summary of your results:</p>
            <div id="summaryResults">
                 </div>
            <button id="restartBtn">Restart Task</button>
            <div id="developerDataContainer">
                <strong>Download Data:</strong>
                <button id="developerDataButtonJson">JSON</button>
                <button id="developerDataButtonCsv">CSV</button>
             </div>
        </div>
    </div>

    <script>
        // --- Element References (Add noiseOverlay) ---
        const continueToInfoBtn = document.getElementById('continueToInfoBtn');
        // ... (other references from previous version)
        const participantInfoDiv = document.getElementById('participantInfo');
        const infoForm = document.getElementById('infoForm');
        const participantIdInput = document.getElementById('participantId');
        const ageInput = document.getElementById('age');
        const genderInput = document.getElementById('gender');
        const startTaskBtn = document.getElementById('startTaskBtn');
        const infoErrorDiv = document.getElementById('infoError');

        const taskDiv = document.getElementById('task');
        const fixationDiv = document.getElementById('fixation');
        const stimulusDiv = document.getElementById('stimulus');
        const feedbackDiv = document.getElementById('feedback');
        const noiseOverlay = document.getElementById('noiseOverlay'); // Noise Element
        const summaryDiv = document.getElementById('summary');
        const summaryResultsDiv = document.getElementById('summaryResults');
        const restartBtn = document.getElementById('restartBtn');
        const developerDataButtonJson = document.getElementById('developerDataButtonJson');
        const developerDataButtonCsv = document.getElementById('developerDataButtonCsv');

        // --- Task State Variables ---
        let trials = [];
        let currentTrialIndex = 0;
        let results = [];
        let summaryMetrics = {};
        let participantData = {};
        let stimulusStartTime;
        let responseListener = null;

        // --- Timing Parameters (Added Cue timings) ---
        const INITIAL_FIXATION_DURATION = 400; // Time fixation '+' is shown initially
        const CUE_DURATION = 100;             // Time cue '*' is shown (if cued trial)
        const POST_CUE_DELAY = 200;          // Time between cue offset and stimulus onset
        const FEEDBACK_DURATION = 750;
        const ITI = 500; // Inter-trial interval (after feedback before next fixation)
        // Total pre-stimulus time: INITIAL_FIXATION + CUE + POST_CUE_DELAY = 700ms (or adjust as needed)

        // --- Utility Functions (Shuffle, SD - Same as before) ---
        function shuffleArray(array) { /* ... */ }
        function calculateSD(data, mean) { /* ... */ }
        // Add Median calculation
        function calculateMedian(data) {
             if (!data || data.length === 0) return 0;
             const sortedData = [...data].sort((a, b) => a - b); // Sort numeric
             const mid = Math.floor(sortedData.length / 2);
             if (sortedData.length % 2 === 0) {
                 // Even number of elements: average the two middle ones
                 return (sortedData[mid - 1] + sortedData[mid]) / 2;
             } else {
                 // Odd number of elements: return the middle one
                 return sortedData[mid];
             }
         }

        // --- Define the Trials (96 trials: 2 Congruency x 2 Cue x 2 Noise x 2 Target Sets x 6 Reps) ---
        function setupTrials() {
            const letters = {
                set1: ['A', 'K'], // Respond 'F'
                set2: ['L', 'R']  // Respond 'J'
            };
            const conditions = {
                congruency: ['congruent', 'incongruent'],
                cue: ['none', 'center'],
                noise: ['no', 'yes']
            };

            const baseTrials = [];

            // Loop through all condition combinations
            for (const cong of conditions.congruency) {
                for (const cueType of conditions.cue) {
                    for (const noiseType of conditions.noise) {
                        // Create trials for both target sets
                        for (const targetSetKey in letters) {
                             const targetSet = letters[targetSetKey];
                             const flankerSet = targetSetKey === 'set1' ? letters.set2 : letters.set1;
                             const correctKey = targetSetKey === 'set1' ? 'f' : 'j';

                             // Pick one target letter from the set randomly for this trial block
                             const targetLetter = targetSet[Math.floor(Math.random() * targetSet.length)];

                             let stimulus = "";
                             if (cong === 'congruent') {
                                 // All letters are the same target letter
                                 stimulus = targetLetter.repeat(5);
                             } else { // incongruent
                                 // Center is target, flankers are from the *other* set
                                 const flankerLetter = flankerSet[Math.floor(Math.random() * flankerSet.length)];
                                 stimulus = `${flankerLetter}${flankerLetter}${targetLetter}${flankerLetter}${flankerLetter}`;
                             }

                             baseTrials.push({
                                 stimulus: stimulus,
                                 centerLetter: targetLetter,
                                 correctKey: correctKey,
                                 condition_congruency: cong,
                                 condition_cue: cueType,
                                 condition_noise: noiseType
                             });
                        }
                    }
                }
            }

             // We need 96 trials = 8 base conditions * 2 target sets = 16 unique types
             // Repeat each unique type 6 times (16 * 6 = 96)
             const repeatedTrials = [];
             for (let i=0; i<6; i++){
                repeatedTrials.push(...baseTrials);
             }


            trials = shuffleArray(repeatedTrials);
            currentTrialIndex = 0;
            results = [];
            console.log(`Setup complete: ${trials.length} trials generated.`);
        }


        // --- Start Experiment Flow (Same as before) ---
        function startExperiment() { /* ... */ }

        // --- Run a Single Trial (Updated for Cue and Noise) ---
        function runTrial(trialIndex) {
            if (trialIndex >= trials.length) {
                endExperiment(); return;
            }
            const currentTrial = trials[trialIndex];

            // Ensure elements are in correct initial state
            taskDiv.classList.remove('hidden');
            stimulusDiv.classList.add('hidden');
            feedbackDiv.classList.add('hidden');
            noiseOverlay.classList.add('hidden'); // Ensure noise overlay is hidden initially
            fixationDiv.textContent = '+'; // Reset to fixation cross
            fixationDiv.classList.remove('hidden');

            // 1. Initial Fixation Period
            setTimeout(() => {
                // 2. Cue Period
                if (currentTrial.condition_cue === 'center') {
                    fixationDiv.textContent = '*'; // Show cue
                } // If 'none', fixation remains '+' or could be blanked

                setTimeout(() => {
                    // 3. Post-Cue Delay (Hide fixation/cue)
                    fixationDiv.classList.add('hidden');

                    setTimeout(() => {
                        // 4. Show Stimulus (and Noise if applicable)
                        stimulusDiv.textContent = currentTrial.stimulus;
                        stimulusDiv.classList.remove('hidden');

                        if (currentTrial.condition_noise === 'yes') {
                             noiseOverlay.classList.remove('hidden'); // Show noise overlay
                        }

                        stimulusStartTime = performance.now(); // Record precise time

                        // Add keyboard listener
                        if (responseListener) document.removeEventListener('keydown', responseListener);
                        responseListener = (event) => handleKeyPress(event, currentTrial);
                        document.addEventListener('keydown', responseListener);

                    }, POST_CUE_DELAY); // Wait after cue offset
                }, CUE_DURATION); // Wait for cue duration
            }, INITIAL_FIXATION_DURATION); // Wait for initial fixation
        }

        // --- Handle Key Press (Updated for New Target Sets) ---
        function handleKeyPress(event, trial) {
            const key = event.key.toLowerCase();
            if (key === 'f' || key === 'j') {
                 const reactionTime = performance.now() - stimulusStartTime;

                 // Determine correct key based on the center letter
                 let expectedKey;
                 if (['a', 'k'].includes(trial.centerLetter.toLowerCase())) {
                     expectedKey = 'f';
                 } else if (['l', 'r'].includes(trial.centerLetter.toLowerCase())) {
                     expectedKey = 'j';
                 } else {
                     expectedKey = '?'; // Should not happen with current setup
                 }
                 const correct = key === expectedKey;

                 document.removeEventListener('keydown', responseListener);
                 responseListener = null;
                 stimulusDiv.classList.add('hidden');
                 noiseOverlay.classList.add('hidden'); // Hide noise overlay

                 // Store detailed raw data
                 results.push({
                     participantId: participantData.id,
                     age: participantData.age,
                     gender: participantData.gender,
                     trialIndex: currentTrialIndex,
                     stimulus: trial.stimulus,
                     centerLetter: trial.centerLetter,
                     congruency: trial.condition_congruency,
                     cue: trial.condition_cue,
                     noise: trial.condition_noise,
                     response: key,
                     correctKey: expectedKey, // Store the determined correct key
                     correct: correct ? 1 : 0,
                     rt: reactionTime
                 });

                 showFeedback(correct);

                 setTimeout(() => {
                     currentTrialIndex++;
                     runTrial(currentTrialIndex);
                 }, FEEDBACK_DURATION + ITI);
            }
        }

        // --- Show Feedback (Same as before) ---
        function showFeedback(correct) { /* ... */ }


        // --- End Experiment and Calculate Metrics (Updated for Min/Max/Median) ---
        function endExperiment() {
            console.log("Experiment ended. Calculating metrics...");
            taskDiv.classList.add('hidden');

            let correctRTs = [];
            let congruentCorrectRTs = [];
            let incongruentCorrectRTs = [];
            // Add arrays for cue/no cue, noise/no noise if detailed breakdown needed
            // ... (rest of counter variables from previous version)
             let correctCount = 0;
             let totalCorrectRT = 0;
             let congruentCorrectCount = 0;
             let incongruentCorrectCount = 0;
             let congruentTotal = 0;
             let incongruentTotal = 0;
             let congruentCorrectRTtotal = 0;
             let incongruentCorrectRTtotal = 0;


            results.forEach(res => {
                if (res.congruency === 'congruent') congruentTotal++;
                if (res.congruency === 'incongruent') incongruentTotal++;

                if (res.correct === 1) {
                    correctCount++;
                    totalCorrectRT += res.rt;
                    correctRTs.push(res.rt); // Collect all correct RTs

                    if (res.congruency === 'congruent') {
                        congruentCorrectCount++;
                        congruentCorrectRTtotal += res.rt;
                        congruentCorrectRTs.push(res.rt);
                    } else if (res.congruency === 'incongruent') {
                        incongruentCorrectCount++;
                        incongruentCorrectRTtotal += res.rt;
                        incongruentCorrectRTs.push(res.rt);
                    }
                    // Add similar logic here to collect RTs based on cue and noise conditions if needed
                }
            });

             const totalTrials = results.length;
             const overallAccuracy = totalTrials > 0 ? (correctCount / totalTrials) * 100 : 0;
             const overallMeanRT = correctCount > 0 ? (totalCorrectRT / correctCount) : 0;
             const overallSDRT = calculateSD(correctRTs, overallMeanRT);
             const errorRate = 100 - overallAccuracy;

             // NEW Metrics
             const overallMinRT = correctRTs.length > 0 ? Math.min(...correctRTs) : 0;
             const overallMaxRT = correctRTs.length > 0 ? Math.max(...correctRTs) : 0;
             const overallMedianRT = calculateMedian(correctRTs);


             const congruentAccuracy = congruentTotal > 0 ? (congruentCorrectCount / congruentTotal) * 100 : 0;
             const incongruentAccuracy = incongruentTotal > 0 ? (incongruentCorrectCount / incongruentTotal) * 100 : 0;
             const congruentMeanRT = congruentCorrectCount > 0 ? (congruentCorrectRTtotal / congruentCorrectCount) : 0;
             const incongruentMeanRT = incongruentCorrectCount > 0 ? (incongruentCorrectRTtotal / incongruentCorrectCount) : 0;
             const congruentSDRT = calculateSD(congruentCorrectRTs, congruentMeanRT);
             const incongruentSDRT = calculateSD(incongruentCorrectRTs, incongruentMeanRT);
             const interferenceRT = (congruentMeanRT > 0 && incongruentMeanRT > 0) ? (incongruentMeanRT - congruentMeanRT) : 'N/A';
             const interferenceAccuracy = (congruentAccuracy - incongruentAccuracy);

            // Store calculated metrics (add new ones)
            summaryMetrics = {
                totalTrials: totalTrials,
                overallAccuracy: overallAccuracy.toFixed(2),
                overallMeanRT_ms: overallMeanRT.toFixed(2),
                overallMedianRT_ms: overallMedianRT.toFixed(2), // Added Median
                overallMinRT_ms: overallMinRT.toFixed(2),       // Added Min
                overallMaxRT_ms: overallMaxRT.toFixed(2),       // Added Max
                overallSDRT_ms: overallSDRT.toFixed(2),
                errorRate: errorRate.toFixed(2),
                // ... (Congruent/Incongruent metrics from previous version)
                congruentTotal: congruentTotal,
                congruentAccuracy: congruentAccuracy.toFixed(2),
                congruentMeanRT_ms: congruentMeanRT.toFixed(2),
                congruentSDRT_ms: congruentSDRT.toFixed(2),
                incongruentTotal: incongruentTotal,
                incongruentAccuracy: incongruentAccuracy.toFixed(2),
                incongruentMeanRT_ms: incongruentMeanRT.toFixed(2),
                incongruentSDRT_ms: incongruentSDRT.toFixed(2),
                interferenceRT_ms: typeof interferenceRT === 'number' ? interferenceRT.toFixed(2) : interferenceRT,
                interferenceAccuracy: interferenceAccuracy.toFixed(2)
                // Add metrics broken down by Cue and Noise if calculated
            };

            // Display summary to participant (add Median RT)
            summaryResultsDiv.innerHTML = `
                <ul>
                    <li>Overall Accuracy: ${summaryMetrics.overallAccuracy}%</li>
                    <li>Average Correct Reaction Time: ${summaryMetrics.overallMeanRT_ms} ms</li>
                    <li>Median Correct Reaction Time: ${summaryMetrics.overallMedianRT_ms} ms</li>
                    <li>RT Range (Min-Max): ${summaryMetrics.overallMinRT_ms} - ${summaryMetrics.overallMaxRT_ms} ms</li>
                    <li>Reaction Time Interference (Incongruent - Congruent): ${summaryMetrics.interferenceRT_ms} ms</li>
                </ul>
            `;
            summaryDiv.classList.remove('hidden');
        }

        // --- Function to Convert Data to CSV ---
        function convertToCSV(dataArray) {
            if (!dataArray || dataArray.length === 0) {
                return "";
            }
            const headers = Object.keys(dataArray[0]);
            const csvRows = [
                headers.join(',') // Header row
            ];
            dataArray.forEach(row => {
                // Map values in the order of headers, handle potential commas/quotes if necessary (simple case here)
                const values = headers.map(header => row[header]);
                csvRows.push(values.join(','));
            });
            return csvRows.join('\n');
        }


        // --- Function to trigger Data Download (Updated for CSV) ---
        function downloadData(format = 'json') { // Default to JSON
             const date = new Date();
             const timestamp = `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, '0')}${String(date.getDate()).padStart(2, '0')}_${String(date.getHours()).padStart(2, '0')}${String(date.getMinutes()).padStart(2, '0')}${String(date.getSeconds()).padStart(2, '0')}`;
             const baseFilename = `flanker_results_${participantData.id}_${timestamp}`;

             let dataStr = "";
             let mimeType = "";
             let filename = "";

             if (format === 'csv') {
                 // Combine participant info, summary (maybe as comments?), and raw data
                 // Simple approach: CSV only contains raw trial data for easy import
                 dataStr = convertToCSV(results);
                 mimeType = "text/csv";
                 filename = `${baseFilename}.csv`;
             } else { // Default to JSON
                 dataStr = JSON.stringify({
                     participantInfo: participantData,
                     summaryMetrics: summaryMetrics,
                     rawData: results
                 }, null, 2);
                 mimeType = "application/json";
                 filename = `${baseFilename}.json`;
             }

             const blob = new Blob([dataStr], {type: mimeType});
             const url = URL.createObjectURL(blob);
             const a = document.createElement('a');
             a.download = filename;
             a.href = url;
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);
             URL.revokeObjectURL(url);
             console.log(`${format.toUpperCase()} data download initiated.`);
        }


        // --- Event Listeners (Updated for new download buttons) ---
        continueToInfoBtn.addEventListener('click', () => {
    welcomeDiv.classList.add('hidden');     // Hide welcome screen
    participantInfoDiv.classList.remove('hidden');  // Show participant info screen
});
        infoForm.addEventListener('submit', (event) => { /* ... */ });
        restartBtn.addEventListener('click', () => { /* ... */ });

        // Attach listeners to specific download buttons
        developerDataButtonJson.addEventListener('click', () => downloadData('json'));
        developerDataButtonCsv.addEventListener('click', () => downloadData('csv'));

        // --- Initialize Utility Functions ---
        // Need to put the actual implementation for shuffleArray and calculateSD here
        // (Copied from previous implementation for completeness)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
            return array;
        }
        function calculateSD(data, mean) {
             if (!data || data.length === 0) return 0;
              // Use Sample SD (N-1 denominator) - common in stats packages
              const N = data.length;
              if (N < 2) return 0; // Need at least 2 points for sample SD
              const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / (N - 1);
              return Math.sqrt(variance);
        }

    </script>
</body>
</html>
