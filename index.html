<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flanker Task (Timeout Added)</title>
    <style>
        /* Basic CSS */
        body {
            font-family: Arial, sans-serif; text-align: center; background-color: #f8f9fa;
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh;
        }
        .container {
            max-width: 700px; padding: 30px; border: 1px solid #ccc; background-color: #ffffff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        /* Task Area Positioning */
        #task { position: relative; }

        #stimulus, #fixation {
            font-size: 80px; font-family: 'Courier New', Courier, monospace; margin: 40px 0;
            height: 90px; line-height: 90px; color: #333;
            white-space: pre;
        }
        #fixation { font-size: 50px; }

        /* Noise Overlay Styling - Slightly more visible opacity */
        #noiseOverlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-image: radial-gradient(circle, rgba(0,0,0,0.12) 1px, transparent 1px);
            background-size: 3px 3px;
            opacity: 0.7; /* Increased slightly from 0.6 */
            pointer-events: none;
            z-index: 10;
        }

        button { /* Styles remain the same */ }
        button:hover { /* Styles remain the same */ }
        .hidden { display: none; }
        #summary ul, #instructions ul, #participantInfo form { /* Styles remain the same */ }
        #summary li, #instructions li, #participantInfo label, #participantInfo input, #participantInfo select { /* Styles remain the same */ }
        #participantInfo input, #participantInfo select { /* Styles remain the same */ }
        #participantInfo label { /* Styles remain the same */ }
        #feedback { /* Styles remain the same */ }
        .correct { color: green; }
        .incorrect { color: red; } /* Also used for 'Too Slow' */
        .error-message { /* Styles remain the same */ }
        #developerDataButton { /* Styles remain the same */ }
        #developerDataButton:hover { /* Styles remain the same */ }
    </style>
</head>
<body>
    <div class="container">
        <div id="instructions">
            <h2>Welcome to the Flanker Task</h2>
            <p>Please read the instructions carefully.</p>
            <p>You will first be asked for some basic information.</p>
            <p>Keep your eyes focused on the center of the screen.</p>
            <p>A fixation cross '+' will appear, followed by a sequence of 5 letters.</p>
            <p>The letters may appear close together or further apart.</p>
            <p>Some trials may have visual noise overlaying the letters.</p>
            <p>Your task is to identify the <strong>center letter</strong> and ignore the surrounding letters and any noise or spacing.</p>
            <ul id="instructionList">
                 <li>Press <strong>F</strong> if the center letter is <strong>A</strong> or <strong>K</strong></li>
                 <li>Press <strong>J</strong> if the center letter is <strong>L</strong> or <strong>R</strong></li>
            </ul>
            <p>Please respond as quickly and accurately as possible. You have 1.5 seconds to respond to each set of letters.</p> {/* Timeout mention */}
            <p>Click "Continue" to enter your information.</p>
            <button id="continueToInfoBtn">Continue</button>
        </div>

        <div id="participantInfo" class="hidden">
            <h2>Participant Information</h2>
            <form id="infoForm">
                <label for="participantId">Participant ID (5 digits):</label>
                <input type="text" id="participantId" name="participantId" pattern="\d{5}" required maxlength="5" title="Enter exactly 5 digits">
                <label for="age">Age:</label>
                <input type="number" id="age" name="age" required min="1" max="120">
                <label for="gender">Gender:</label>
                <select id="gender" name="gender" required>
                    <option value="">--Please select--</option>
                    <option value="Male">Male</option>
                    <option value="Female">Female</option>
                    <option value="Non-binary">Non-binary</option>
                    <option value="Other">Other</option>
                    <option value="Prefer_not_to_say">Prefer not to say</option>
                </select>
                <button type="submit" id="startTaskBtn">Start Task</button>
                <div id="infoError" class="error-message hidden">Please fill out all fields correctly.</div>
            </form>
        </div>

        <div id="task" class="hidden">
            <div id="noiseOverlay" class="hidden"></div>
            <div id="fixation">+</div>
            <div id="stimulus" class="hidden"></div>
            <div id="feedback" class="hidden"></div>
        </div>

        <div id="summary" class="hidden">
             <h2>Task Complete!</h2>
             <p>Here is a summary of your results:</p>
             <div id="summaryResults"></div>
             <button id="restartBtn">Restart Task</button>
             <button id="developerDataButton">Download Raw Data (CSV)</button>
        </div>
    </div>

    <script>
        // --- Get References (Unaltered) ---
        const continueToInfoBtn = document.getElementById('continueToInfoBtn');
        const instructionsDiv = document.getElementById('instructions');
        const participantInfoDiv = document.getElementById('participantInfo');
        const infoForm = document.getElementById('infoForm');
        const participantIdInput = document.getElementById('participantId');
        const ageInput = document.getElementById('age');
        const genderInput = document.getElementById('gender');
        const startTaskBtn = document.getElementById('startTaskBtn');
        const infoErrorDiv = document.getElementById('infoError');
        const taskDiv = document.getElementById('task');
        const fixationDiv = document.getElementById('fixation');
        const stimulusDiv = document.getElementById('stimulus');
        const feedbackDiv = document.getElementById('feedback');
        const noiseOverlay = document.getElementById('noiseOverlay');
        const summaryDiv = document.getElementById('summary');
        const summaryResultsDiv = document.getElementById('summaryResults');
        const restartBtn = document.getElementById('restartBtn');
        const developerDataButton = document.getElementById('developerDataButton');

        // --- Task State Variables (Added trialTimeoutId) ---
        let trials = [];
        let currentTrialIndex = 0;
        let results = [];
        let summaryMetrics = {};
        let participantData = {};
        let stimulusStartTime;
        let experimentStartTime;
        let responseListener = null;
        let trialTimeoutId = null; // <<< Added for timeout

        // --- Timing Parameters (Added MAX_RESPONSE_TIME) ---
        const FIXATION_DURATION = 500;
        const FEEDBACK_DURATION = 750;
        const ITI = 500;
        const MAX_RESPONSE_TIME = 1500; // <<< Added timeout duration (1.5 seconds)

        // --- Utility Functions (Unaltered) ---
        function shuffleArray(array) { /* ... */ }
        function calculateSD(data, mean) { /* ... */ }
        function calculateMedian(data) { /* ... */ }
        function formatStimulusWithSpacing(stimulusString, spacingType) { /* ... */ }

        // --- Define Trials (Unaltered) ---
        function setupTrials() { /* ... */ }

        // --- Start Experiment Flow (Unaltered) ---
        function startExperiment() { /* ... */ }

        // --- Run a Single Trial (Added timeout start) ---
        function runTrial(trialIndex) {
            if (trialIndex >= trials.length) { endExperiment(); return; }
            const currentTrial = trials[trialIndex];

            // Clear previous timeout if exists
            if (trialTimeoutId) clearTimeout(trialTimeoutId);

            taskDiv.classList.remove('hidden');
            stimulusDiv.classList.add('hidden');
            feedbackDiv.classList.add('hidden');
            noiseOverlay.classList.add('hidden');
            fixationDiv.textContent = '+';
            fixationDiv.classList.remove('hidden');

            setTimeout(() => {
                fixationDiv.classList.add('hidden');

                const formattedStimulus = formatStimulusWithSpacing(
                    currentTrial.stimulus_base, currentTrial.condition_spacing
                );
                stimulusDiv.innerHTML = formattedStimulus;
                stimulusDiv.classList.remove('hidden');

                if (currentTrial.condition_noise === 'yes') {
                    noiseOverlay.classList.remove('hidden');
                    // console.log("Noise overlay shown"); // Optional debug log
                } else {
                    // console.log("Noise overlay hidden"); // Optional debug log
                }

                stimulusStartTime = performance.now();

                if (responseListener) document.removeEventListener('keydown', responseListener);
                responseListener = (event) => handleKeyPress(event, currentTrial);
                document.addEventListener('keydown', responseListener);

                // <<< Start timeout for this trial >>>
                trialTimeoutId = setTimeout(() => {
                    handleTimeout(currentTrial);
                }, MAX_RESPONSE_TIME);

            }, FIXATION_DURATION);
        }

        // --- Handle Key Press (Added timeout clear) ---
        function handleKeyPress(event, trial) {
            const key = event.key.toLowerCase();
            if (key === 'f' || key === 'j') {

                // <<< Clear the response timeout >>>
                clearTimeout(trialTimeoutId);
                trialTimeoutId = null;
                // <<< --- >>>

                const reactionTime = performance.now() - stimulusStartTime;
                let expectedKey;
                const centerLower = trial.centerLetter.toLowerCase();
                if (['a', 'k'].includes(centerLower)) expectedKey = 'f';
                else if (['l', 'r'].includes(centerLower)) expectedKey = 'j';
                else expectedKey = '?';
                const correct = key === expectedKey;

                document.removeEventListener('keydown', responseListener);
                responseListener = null;
                stimulusDiv.classList.add('hidden');
                noiseOverlay.classList.add('hidden');

                results.push({
                    participantId: participantData.id, age: participantData.age, gender: participantData.gender,
                    trialIndex: currentTrialIndex, stimulus: trial.stimulus_base, centerLetter: trial.centerLetter,
                    congruency: trial.condition_congruency, noise: trial.condition_noise, spacing: trial.condition_spacing,
                    response: key, correctKey: expectedKey, correct: correct ? 1 : 0,
                    latency_ms: reactionTime
                });

                showFeedback(correct ? "Correct" : "Incorrect"); // <<< Pass message string

                setTimeout(() => {
                    currentTrialIndex++;
                    runTrial(currentTrialIndex);
                }, FEEDBACK_DURATION + ITI);
            }
        }

        // --- >>> NEW: Handle Timeout Function <<< ---
        function handleTimeout(trial) {
            console.warn(`Timeout on trial ${currentTrialIndex}`);
            trialTimeoutId = null;

            if (responseListener) {
                document.removeEventListener('keydown', responseListener);
                responseListener = null;
            }

            stimulusDiv.classList.add('hidden');
            noiseOverlay.classList.add('hidden');

            results.push({
                participantId: participantData.id, age: participantData.age, gender: participantData.gender,
                trialIndex: currentTrialIndex, stimulus: trial.stimulus_base, centerLetter: trial.centerLetter,
                congruency: trial.condition_congruency, noise: trial.condition_noise, spacing: trial.condition_spacing,
                response: 'timeout', // Indicate timeout
                correctKey: trial.correctKey,
                correct: 0, // Timeout is incorrect
                latency_ms: -1 // Indicate timeout / no response latency
            });

            showFeedback("Too Slow"); // <<< Pass "Too Slow" message

            setTimeout(() => {
                 currentTrialIndex++;
                 runTrial(currentTrialIndex);
            }, FEEDBACK_DURATION + ITI);
        }

        // --- Show Feedback (Modified to accept message) ---
        function showFeedback(message) {
             feedbackDiv.classList.remove('hidden');
             if (message === "Correct") {
                 feedbackDiv.className = 'correct';
                 feedbackDiv.textContent = "Correct";
             } else { // Handles "Incorrect" or "Too Slow"
                 feedbackDiv.className = 'incorrect';
                 feedbackDiv.textContent = message;
             }
         }

        // --- End Experiment (Modified summary calculation/display for timeouts) ---
        function endExperiment() {
              const experimentEndTime = performance.now();
              const totalElapsedTime_ms = experimentEndTime - experimentStartTime;
              console.log("Experiment ended. Calculating metrics...");
              taskDiv.classList.add('hidden');

              let correctCount = 0; let totalCorrectRT = 0; let correctRTs = [];
              let noiseYesCorrect = 0, noiseYesTotal = 0; let noiseNoCorrect = 0, noiseNoTotal = 0;
              let spacingSingleCorrect = 0, spacingSingleTotal = 0; let spacingDoubleCorrect = 0, spacingDoubleTotal = 0; let spacingTripleCorrect = 0, spacingTripleTotal = 0;
              let timeoutCount = 0; // Count timeouts

              results.forEach(res => {
                  if (res.noise === 'yes') noiseYesTotal++; else noiseNoTotal++;
                  if (res.spacing === 'single') spacingSingleTotal++; else if (res.spacing === 'double') spacingDoubleTotal++; else if (res.spacing === 'triple') spacingTripleTotal++;

                  if (res.response === 'timeout') {
                      timeoutCount++;
                  } else if (res.correct === 1) { // Only calculate RT stats for non-timeout correct trials
                      correctCount++;
                      totalCorrectRT += res.latency_ms;
                      correctRTs.push(res.latency_ms); // Collect RTs for Median/Min/Max/SD
                      // Correct counts by condition (only for non-timeout correct trials)
                      if (res.noise === 'yes') noiseYesCorrect++; else noiseNoCorrect++;
                      if (res.spacing === 'single') spacingSingleCorrect++; else if (res.spacing === 'double') spacingDoubleCorrect++; else if (res.spacing === 'triple') spacingTripleCorrect++;
                  }
                  // Note: Accuracy uses correctCount (non-timeout correct) / totalTrials denominator
              });

              const totalTrials = results.length;
              const respondedTrials = totalTrials - timeoutCount;
              // Accuracy relative to ALL trials (timeouts count as errors)
              const overallAccuracy = totalTrials > 0 ? (correctCount / totalTrials) * 100 : 0;
              const overallErrorRate = 100 - overallAccuracy;
               // Accuracy relative to trials that received a response
              const accuracyResponded = respondedTrials > 0 ? (correctCount / respondedTrials) * 100 : 0;

              const overallMeanRT = correctCount > 0 ? (totalCorrectRT / correctCount) : 0;
              const overallSDRT = calculateSD(correctRTs, overallMeanRT);
              const overallMinRT = correctRTs.length > 0 ? Math.min(...correctRTs) : 0;
              const overallMaxRT = correctRTs.length > 0 ? Math.max(...correctRTs) : 0;
              const overallMedianRT = calculateMedian(correctRTs);

              // Accuracy by condition (relative to total trials in that condition)
              const accuracyNoiseYes = noiseYesTotal > 0 ? (results.filter(r => r.noise === 'yes' && r.correct === 1).length / noiseYesTotal) * 100 : 0;
              const accuracyNoiseNo = noiseNoTotal > 0 ? (results.filter(r => r.noise === 'no' && r.correct === 1).length / noiseNoTotal) * 100 : 0;
              const accuracySpacingSingle = spacingSingleTotal > 0 ? (results.filter(r => r.spacing === 'single' && r.correct === 1).length / spacingSingleTotal) * 100 : 0;
              const accuracySpacingDouble = spacingDoubleTotal > 0 ? (results.filter(r => r.spacing === 'double' && r.correct === 1).length / spacingDoubleTotal) * 100 : 0;
              const accuracySpacingTriple = spacingTripleTotal > 0 ? (results.filter(r => r.spacing === 'triple' && r.correct === 1).length / spacingTripleTotal) * 100 : 0;


             summaryMetrics = {
                 totalElapsedTime_s: (totalElapsedTime_ms / 1000).toFixed(2), totalTrials: totalTrials, timeoutCount: timeoutCount,
                 overallAccuracy: overallAccuracy.toFixed(2), overallErrorRate: overallErrorRate.toFixed(2),
                 accuracyAmongResponded: accuracyResponded.toFixed(2),
                 overallMeanRT_ms: overallMeanRT.toFixed(2), overallMedianRT_ms: overallMedianRT.toFixed(2),
                 overallMinRT_ms: overallMinRT.toFixed(2), overallMaxRT_ms: overallMaxRT.toFixed(2), overallSDRT_ms: overallSDRT.toFixed(2),
                 accuracyNoiseYes: accuracyNoiseYes.toFixed(2), accuracyNoiseNo: accuracyNoiseNo.toFixed(2),
                 accuracySpacingSingle: accuracySpacingSingle.toFixed(2), accuracySpacingDouble: accuracySpacingDouble.toFixed(2), accuracySpacingTriple: accuracySpacingTriple.toFixed(2),
             };
             console.log("Summary Metrics:", summaryMetrics);
             summaryResultsDiv.innerHTML = `
                 <ul>
                     <li>Total Task Time: ${summaryMetrics.totalElapsedTime_s} seconds</li>
                     <li>Overall Accuracy: ${summaryMetrics.overallAccuracy}% (${correctCount}/${totalTrials})</li>
                     <li>Timeouts: ${summaryMetrics.timeoutCount}</li>
                     <li>Accuracy (Responded Trials): ${summaryMetrics.accuracyAmongResponded}%</li>
                     <li>Mean Correct Latency: ${summaryMetrics.overallMeanRT_ms} ms</li>
                     <li>Median Correct Latency: ${summaryMetrics.overallMedianRT_ms} ms</li>
                     <li>Latency Range (Min-Max): ${summaryMetrics.overallMinRT_ms} - ${summaryMetrics.overallMaxRT_ms} ms</li>
                     <li>Accuracy (No Noise / Noise): ${summaryMetrics.accuracyNoiseNo}% / ${summaryMetrics.accuracyNoiseYes}%</li>
                     <li>Accuracy (Single / Double / Triple Spacing): ${summaryMetrics.accuracySpacingSingle}% / ${summaryMetrics.accuracySpacingDouble}% / ${summaryMetrics.accuracySpacingTriple}%</li>
                 </ul>`;
             summaryDiv.classList.remove('hidden');

             // <<< Your Google Form Submission Call - UNALTERED >>>
             sendDataToSheet(
                 participantData.id,
                 results, // Sending raw results array
                 summaryMetrics.overallAccuracy, // Sending calculated overall accuracy
                 summaryMetrics.overallMeanRT_ms // Sending calculated overall mean RT
             );
             // <<< --- >>>
         }

        // --- Convert Data to CSV (Unaltered) ---
        function convertToCSV(dataArray) { /* ... */ }

        // --- Trigger CSV Download (Unaltered) ---
        function downloadCSVData() { /* ... */ }

        // --- Event Listeners (Unaltered) ---
        continueToInfoBtn.addEventListener('click', () => { /* ... */ });
        infoForm.addEventListener('submit', (event) => { /* ... */ });
        restartBtn.addEventListener('click', () => { /* ... */ });
        developerDataButton.addEventListener('click', downloadCSVData);

        // --- Utility Functions Implementation (Unaltered - ensure they are present) ---
        function shuffleArray(array) { /* ... */ }
        // Ensure other functions like startExperiment, calculateSD, calculateMedian, formatStimulusWithSpacing, convertToCSV, downloadCSVData are defined exactly as in the previous correct version.
        // (Pasting them again for clarity, ensure they match the previous version you confirmed was working)
        function calculateSD(data, mean) { if (!data || data.length < 2) return 0; const N = data.length; const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / (N - 1); return Math.sqrt(variance); }
        function calculateMedian(data) { if (!data || data.length === 0) return 0; const sortedData = [...data].sort((a, b) => a - b); const mid = Math.floor(sortedData.length / 2); return sortedData.length % 2 === 0 ? (sortedData[mid - 1] + sortedData[mid]) / 2 : sortedData[mid]; }
        function formatStimulusWithSpacing(stimulusString, spacingType) { const letters = stimulusString.split(''); let space = ''; switch (spacingType) { case 'double': space = '\u00A0'; break; case 'triple': space = '\u00A0\u00A0'; break; default: space = ''; break; } return letters.join(space); }
        function startExperiment() { console.log("Starting experiment for participant:", participantData); experimentStartTime = performance.now(); setupTrials(); if (trials.length > 0) { runTrial(currentTrialIndex); } else { console.error("No trials defined!"); } }
        function setupTrials() { const letters = { set1: ['A', 'K'], set2: ['L', 'R'] }; const conditions = { congruency: ['congruent', 'incongruent'], noise: ['no', 'yes'], spacing: ['single', 'double', 'triple'] }; const baseTrials = []; for (const cong of conditions.congruency) { for (const noiseType of conditions.noise) { for (const spacingType of conditions.spacing) { for (const targetSetKey in letters) { const targetSet = letters[targetSetKey]; const flankerSet = targetSetKey === 'set1' ? letters.set2 : letters.set1; const correctKey = targetSetKey === 'set1' ? 'f' : 'j'; const targetLetter = targetSet[Math.floor(Math.random() * targetSet.length)]; let stimulusString = ""; if (cong === 'congruent') { stimulusString = targetLetter.repeat(5); } else { const flankerLetter = flankerSet[Math.floor(Math.random() * flankerSet.length)]; stimulusString = `${flankerLetter}${flankerLetter}${targetLetter}${flankerLetter}${flankerLetter}`; } baseTrials.push({ stimulus_base: stimulusString, centerLetter: targetLetter, correctKey: correctKey, condition_congruency: cong, condition_noise: noiseType, condition_spacing: spacingType }); } } } } const repeatedTrials = []; const reps = 4; for (let i=0; i<reps; i++){ repeatedTrials.push(...baseTrials.map(trial => ({...trial}))); } trials = shuffleArray(repeatedTrials); currentTrialIndex = 0; results = []; console.log(`Setup complete: ${trials.length} trials generated.`); }
        function convertToCSV(dataArray) { if (!dataArray || dataArray.length === 0) return ""; const headers = Object.keys(dataArray[0]); const csvRows = [ headers.join(',') ]; dataArray.forEach(row => { const values = headers.map(header => { let value = row[header]; if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) { value = `"${value.replace(/"/g, '""')}"`; } return value; }); csvRows.push(values.join(',')); }); return csvRows.join('\n'); }
        function downloadCSVData() { const csvData = convertToCSV(results); if (!csvData) { console.error("No data available to download."); alert("No data available to download."); return; } const blob = new Blob([csvData], {type: "text/csv;charset=utf-8;"}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); const date = new Date(); const timestamp = `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, '0')}${String(date.getDate()).padStart(2, '0')}_${String(date.getHours()).padStart(2, '0')}${String(date.getMinutes()).padStart(2, '0')}${String(date.getSeconds()).padStart(2, '0')}`; a.download = `flanker_raw_data_${participantData.id}_${timestamp}.csv`; a.href = url; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); console.log("CSV Data download initiated."); }
        // Event Listeners (ensure they are defined)
        continueToInfoBtn.addEventListener('click', () => { instructionsDiv.classList.add('hidden'); participantInfoDiv.classList.remove('hidden'); });
        infoForm.addEventListener('submit', (event) => { event.preventDefault(); const id = participantIdInput.value; const age = ageInput.value; const gender = genderInput.value; if (id.match(/^\d{5}$/) && age && gender) { participantData = { id: id, age: parseInt(age), gender: gender }; infoErrorDiv.classList.add('hidden'); participantInfoDiv.classList.add('hidden'); startExperiment(); } else { infoErrorDiv.textContent = "Please ensure ID is 5 digits and all fields are filled."; infoErrorDiv.classList.remove('hidden'); } });
        restartBtn.addEventListener('click', () => { summaryDiv.classList.add('hidden'); instructionsDiv.classList.remove('hidden'); });
        developerDataButton.addEventListener('click', downloadCSVData);

    </script>
    <script>
      // Define the function to send data - THIS BLOCK SHOULD BE KEPT AS IS
      function sendDataToSheet(participantID, trialDataArray, accuracy, avgRT) {
        const data = {
          participantID: participantID,
          trialData: trialDataArray, // Sending the whole array might be large
          accuracy: accuracy,
          averageRT: avgRT
          // Consider sending only summary or key metrics if trialData is too large for Google Apps Script limits
        };

        // Log the data being sent for debugging
        console.log("Sending data to Google Sheet:", JSON.stringify(data).substring(0, 500) + "..."); // Log start of data

        fetch("https://script.google.com/macros/s/AKfycbymjapc5sya9P9xXTjDnD5vO7o7ooA0-ORXuMP6to9CcaL_O3MEH87EiALNOlEv_jO5Sw/exec", {
          method: "POST",
          // Using 'text/plain' might help avoid CORS preflight issues sometimes, but depends on Apps Script setup
          // Defaulting back to JSON as it matches the Apps Script likely expectation based on stringify
          headers: {
             "Content-Type": "application/json", // Or "text/plain" if Apps Script parses manually
           },
          body: JSON.stringify(data), // Send the data object as a JSON string
          mode: 'no-cors' // Added 'no-cors' - often needed for simple Apps Script POSTs from browser, but means you won't get response back
        })
        // .then((response) => response.text()) // Cannot read response in no-cors mode
        // .then((text) => console.log("Server response:", text)) // Cannot read response in no-cors mode
        .then(() => console.log("Data submission attempted (no-cors mode). Check Google Sheet.")) // Confirmation
        .catch((error) => console.error("❌ Error sending data:", error)); // Network errors still caught
      }
    </script>
    </body>
</html>


